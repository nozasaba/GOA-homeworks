# 1) მიიყვანეთ ჯგუფური პროექტები საბოლოო ეტაპამდე

# 2) შექმენით ფუნქცია რომელსაც არგუმენტად ინტეჯერების სიას და მომხმარებლის პასუხს გადასცემთ. მომხმარებელს აარჩევინეთ ამ სიიდან ერთ-ერთი რიცხვი და დათვალეთ თუ რამდენჯერ მეორდება ეს რიცხვი სიაში.

# 3) შექმენით ფუნქცია, რომელსაც გადასცემთ 2 არგუმენტს: სია, მომხმარებლის პასუხი. ფუნქციის მიხედვით მომხმარებელს ჰკითხე სურს თუ არა სიის გასუფთავება. თუ დაგთანხმდება გაასუფთავე სია თუ არა მაშინ ჩვეულებრივად გამოიტანე ეს სია ტერმინალში.

# 4) შექმენით სია სახელად Fruits და ჩაამატეთ მასში ხილი. მომხმარებელს შემოატანინეთ ინდექსი და შემდეგ  ამ ინდექსზე მდგომი ელემენტი ამოშალე სიიდან. საბოლოოდ დაბეჭდე სიის საბოლოო ვერსია.

# 5) დაწერეთ ფუნქცია, რომელიც შეამოწმებს არგუმენტად გადაცემული რიცხვი მარტივია თუ არა. (მარტივია რიცხვი, თუ მას მხოლოდ ორი გამყოფი აქვს). მინიშნება: გამოიყენეთ For loop და % გამყოფი ოპერატორი.

# რესურსი:


def count_occurrences(lst, num):
    return lst.count(num)

numbers = [1, 2, 3, 2, 4, 2, 5]
user_choice = 2
print(f"რიცხვი {user_choice} სიაში მეორდება {count_occurrences(numbers, user_choice)}-ჯერ.")

def clear_list(lst, answer):
    if answer.lower() == "დიახ":
        lst.clear()
        return "სია გასუფთავდა!"
    else:
        return lst

nums = [1, 2, 3, 4]
print(clear_list(nums, "არა")) 
print(clear_list(nums, "დიახ")) 


fruits = ["ვაშლი", "ბანანი", "ატამი", "მსხალი", "კივი"]

index = 2   
if 0 <= index < len(fruits):
    fruits.pop(index)

print("საბოლოო სია:", fruits)


def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

print(is_prime(7))  
print(is_prime(12))  
